#+TITLE: Processament de les dades de la llista TOP500
#+SUBTITLE: Tractament de les dades per preparar-les i obtenir-ne informació
#+DESCRIPTION: Pràctica de Tipologia i cicle de vida de les dades, quadrimestre Febrer—Juny 2018
#+DATE: <2018-06-10 Sun>
#+AUTHOR: Pep Turró Mauri
#+EMAIL: jturro@uoc.edu
#+KEYWORDS: tipologia, dades, data science, top500, UOC
#+CREATOR: Emacs 25.3.1 (Org mode 8.2.10)
#+OPTIONS: ':t *:t -:t ::t <:t H:3 \n:nil ^:t arch:headline author:t c:nil
#+OPTIONS: creator:nil d:(not "LOGBOOK") date:t e:t email:nil f:t inline:t
#+OPTIONS: num:t p:nil pri:nil stat:t tags:t tasks:t tex:t timestamp:t toc:t
#+OPTIONS: todo:t |:t
#+OPTIONS: texht:t
# from org-mode-R-tutorial:
#+OPTIONS:    H:3 num:t toc:2 \n:nil @:t ^:{} TeX:t LaTeX:t skip:t d:(HIDE) tags:not-in-toc
#+STARTUP:    align fold nodlcheck hidestars oddeven lognotestate 
#+EXCLUDE_TAGS: noexport
#+LANGUAGE: en
#+PROPERTY: header-args:R :tangle yes  :session *R* :results value :exports results
# http://www.tex.ac.uk/FAQ-fixnam.html
#+LaTeX_HEADER: \renewcommand{\contentsname}{Índex}
#+LaTeX_HEADER: \renewcommand{\figurename}{Figura}
#+LaTeX_HEADER: \renewcommand{\tablename}{Taula}
#+LaTeX_HEADER: \renewcommand{\referencesname}{Bibliografia}
#+LATEX_HEADER: \usepackage{url}
# http://orgmode.org/worg/org-contrib/babel/examples/article-class.html#latex-classfile
#+LATEX_HEADER: \usepackage[hyperref,x11names]{xcolor}
#+LaTeX_CLASS_OPTIONS: [a4paper,colorlinks,urlcolor=SteelBlue4,linkcolor=Firebrick4,pdfusetitle]

* Descripció del dataset
  :PROPERTIES:
  :CUSTOM_ID: descr
  :END:
# Perquè és important i quina pregunta/problema pretèn respondre?

Les dades sobre les que treballem son un històric del llistat dels
superordinadors més potents del món, en funció del seu rendiment a les proves
[[https://ca.wikipedia.org/wiki/LINPACK][LINPACK]]. Aquestes llistes les manté el [[https://www.top500.org/][projecte TOP500]], que publica dos cops
l’any (cada Juny i Novembre) la llista actualitzada dels 500 ordinadors amb
millor rendiment Linpack del moment.

El conjunt de dades conté les entrades de totes les llistes TOP500 publicades
fins ara, amb un registre per cada entrada a una llista. Cal dir que un mateix
sistema sol aparèixer en més d’una llista: des de la seva entrada al TOP500, en
edicions posteriors pot anar baixant, és a dir, pot aparèixer de nou en una
posició diferent.

L'anàlisi d'aquestes dades ens pot servir per obtenir informació diversa, però
un tema comú serà l'estudi de l'evolució de la tecnologia de computació. En
particular, les dades ens seran útils per observar les implicacions de la llei
de Moore \cite{wiki:moore_law}.

George Moore va predir \cite{ieee:moore} que el nombre de transistors que pot
contenir un circuit integrat es doblaria cada dos anys. A la pràctica, aquest
augment de capacitat dels processadors té conseqüències directes sobre la
capacitat de càlcul, la quantitat de memòria disponible, i el cost, entre
altres. Tot i que les dades de què disposem no permeten contrastar la llei de
Moore tal i com està formulada, si que en podrem observar aquestes conseqüències
directes, que són tan o més interessants.

Més enllà d'observar l'evolució del rendiment, podrem veure diferents aspectes
d'aquesta evolució: els fabricants implicats, les àrees d'aplicació dels
superordinadors, els canvis a nivell de sistema operatiu, quins països han
apostat per la supercomputació, o si augmenta l'eficiència en consum d'energia.
Un altre exemple el trobem a \cite{git:dlenski}, que va utilitzar les mateixes
dades per observar l'evolució de les arquitectures d'ordinadors als
superordinadors i els països amb superordinadors instal·lats.

També ens podem plantejar estudiar quins factors contribueixen més a l'increment
de la potència de càlcul: influeix gaire la quantitat de memòria disponible? i
el nombre de nuclis?

* Integració i selecció de les dades d'interès a analitzar
  :PROPERTIES:
  :CUSTOM_ID: integ
  :END:

Carreguem les dades capturades anteriorment via web scraping:

#+BEGIN_SRC R :exports code
  # Carreguem les dades, corregint tipus d'atributs quan cal
  col.classes <- c(
      'site_id'     = 'factor',
      'system_id'   = 'factor',
      'name'        = 'character',
      'site_name'   = 'character',
      'system_url'  = 'character',
      'site_url'    = 'character'
  )
  top500 <- read.csv('../data/top500.csv',
                     na.strings = '',
                     colClasses = col.classes)
  str(top500)
#+END_SRC

#+RESULTS:

El data frame conté src_R{nrow(top500)} registres amb src_R{ncol(top500)}
variables: src_R{toString(names(top500))}.

L'estructura de les dades es troba detallada a [[https://github.com/codificat/top500/blob/master/top500.org#estructura-de-les-dades-capturades][l'informe de la captura de
dades]]. En aquest document també s'explica [[https://github.com/codificat/top500/blob/master/top500.org#origen-dels-camps][l'origen i el contingut]] de cadascun
dels camps. Cal destacar que dos dels camps (/name/ i /gpu/) ja provenen d'un
cert pre-processament de les dades d'origen: aquests s'han calculat a partir
d'un camp original /System/ que ja no és part del conjunt de dades amb què
treballem, sinó que s'ha processat per calcular aquests dos.

A l'hora de fer anàlisi de les dades no utilitzarem cap de les variables de
metadades (identificadors, noms i adreces web), sino que només treballarem amb
les variables descriptives, tant quantitatives com qualitatives. Així doncs,
eliminem les variables de metadades:

#+BEGIN_SRC R :results silent :exports code
  # Descartem variables que no són útils per l'anàlisi de les dades.
  # Mantenim system_id per si ens cal identificar un mateix sistema
  # a diverses edicions de la llista.
  descarta <- c('site_id', 'name', 'site_name', 'system_url', 'site_url')
  top500 <- top500[ , !(names(top500) %in% descarta) ]
#+END_SRC

Una nota sobre integració de dades: a l'hora de fer la captura ja es va notar
que per fer un bon processament de les dades [[https://github.com/codificat/top500/blob/master/top500.org#origen-dels-camps][convindria creuar informació]] amb
bases de dades específiques sobre processadors i coprocessadors. He estat
cercant una font per aquesta informació que fós accessible i fàcil d'integrar
però no l'he trobada; obtenir aquesta informació probablement implicaria un
altre projecte de web scraping, i no hi ha hagut temps. A més, com veurem quan
[[#valors-nuls][revisem els valors buits]], hi ha una gran quantitat de registres que no tenen
informació sobre coprocessador (variable /gpu/), fent-la per tant menys valuosa
per a l'anàlisi; el considerable esforç que implicaria el creuament de
dades millorar la qualitat d'aquest camp no es justifica donada la seva poca
rellevància: tenim prou anàlisi per fer amb altres variables.

* Neteja de les dades

** Preparació

Abans de començar el procés de neteja prepararem una mica el terreny per
poder facilitar la manipulació de les dades.

*** Funcions útils

Per algunes de les operacions que farem a continuació ens vindrà bé tenir una
funció per ajuntar els valors semblants d'una variable categòrica sota un mateix
nom:

#+BEGIN_SRC R :results silent :exports code
  # Creem una funcio per ajuntar els valors que coincideixen amb un patro.
  # Tots els factors que coincideixin amb el patró seran substituïts pel
  # nou valor
  mergelevels <- function(x, pattern, newvalue, ...) {
    # aquesta funció només modifica valors categòrics
    if (class(x) == "factor") {
      sel <- grep(pattern, levels(x), ...)
      levels(x)[ sel ] <- newvalue
    }
    x
  }
#+END_SRC

*** Número d'edició de la llista / data de la llista
    :PROPERTIES:
    :CUSTOM_ID: edition
    :END:

Farem un pre-processament de les dades des d'un punt de vista pràctic que ens
permeti consultar-les d'una forma una mica més còmoda.

L'edició de la llista està representada per dos camps: l'any i el mes. Ens pot
resultar més pràctic poder referir-nos a una edició concreta utilitzant un únic
camp, i potser ens sigui útil fer-ho per ordre (número d'edició de la llista) o
per data (directament amb un camp). Per això crearem dos camps nous:

  - /list/: data d'edició de la llista. Les edicions tenen mes i any, assumirem
    que són del dia 1 del mes.
  - /edition/: número d'edició de la llista, en ordre seqüencial en que s'han
    publicat.

#+BEGIN_SRC R :exports code :results silent
  # Creem un nou camp "list" que contingui la data de la llista
  top500$list <- as.Date(
      ISOdate(top500$year, top500$month, 1, c(0,12))
  )
  # Creem un nou camp "edition" amb el número d'edició de la llista
  # (la primera llista que es va publicar serà la edició número 1, etc)
  top500$edition <- factor(top500$list)
  levels(top500$edition) <- order(levels(top500$edition))
  top500$edition <- as.integer(top500$edition)
#+END_SRC

Un cop tenim aquestes noves variables, les originals /year/ i /month/ ens seran
menys útils. L'any encara ens pot servir per visualitzar millor certes gràfiques,
però la del mes ens és innecessària i l'eliminarem:

#+BEGIN_SRC R :results silent :exports code
  # Eliminem la variable month, que ja no farem servir
  top500 <- subset(top500, select = -month)
#+END_SRC

** TODO COMMENT Visualització prèvia de les dades

** Correcció d'unitats

Durant l'elaboració d'aquest anàlisi vaig adonar-me d'un problema que va passar
desapercebut durant la captura de les dades: en un punt de la història de les
llistes TOP500 les unitats de mesura de la potència de càlcul van passar de
GFlop/s a TFlop/s!

Ho podem veure si mirem la progressió de /rmax/ de l'ordinador més potent per
anys:

#+BEGIN_SRC R :exports both
  # Veure com hi ha un canvi d'ordre de magnitud a rmax
  top500[top500$rank == 1 & top500$month == 6, c('year', 'rmax')]
#+END_SRC

#+RESULTS:
#+begin_example
      year    rmax
1     1993    59.7
1001  1994   143.4
2001  1995   170.0
3001  1996   220.4
4001  1997  1068.0
5001  1998  1338.0
6001  1999  2121.0
7001  2000  2379.0
8001  2001  7226.0
9001  2002 35860.0
10001 2003 35860.0
11001 2004 35860.0
12001 2005   136.8
13001 2006   280.6
14001 2007   280.6
15001 2008  1026.0
16001 2009  1105.0
17001 2010  1759.0
18001 2011  8162.0
19001 2012 16324.8
20001 2013 33862.7
21001 2014 33862.7
22001 2015 33862.7
23001 2016 93014.6
24001 2017 93014.6
#+end_example

He verificat que a partir de la llista del Juny de 2005 (edició número 25) tots
els valors de /rmax/ i /rpeak/ són en TFlop/s[fn:1], mentre que a totes les
edicions anteriors estaven en GFlop/s[fn:2].

Corregirem doncs els valors perquè estiguin tots en la mateixa unitat (GFlop/s):

#+BEGIN_SRC R :exports code :results silent
  # Passem les mesures més recents, que estan en TFlops, a GFlops per
  # tal que els valors de rmax i rpeak estiguin en la mateixa unitat
  top500[top500$edition > 24, 'rmax'] <- 1000 *
      top500[top500$edition > 24, 'rmax']
  top500[top500$edition > 24, 'rpeak'] <- 1000 *
      top500[top500$edition > 24, 'rpeak']
#+END_SRC

** Duplicitats, simplificació d'informació

A les dades hi ha una certa redundància a les variables qualitatives: certs
valors diferents però no prou, ja que les diferències no aporten informació
útil. En aquests casos el que farem és unificar els valors semblants quan tingui
sentit.

*** Mateix fabricant amb diferent nom

#+BEGIN_SRC R :results siltent :exports none
  # Ens guardem quants fabricants diferents hi ha a les dades originals
  fabricants <- nlevels(top500$manufacturer)
#+END_SRC

#+RESULTS:
: 124

La variable /manufacturer/ (el fabricant de l'ordinador) té uns quants casos de
valors que són duplicats amb certes variacions, com per exemple /"Cray
Computer"/ i /"Cray Inc."/, que voldrem unir sota un únic valor.

En certs casos no és tan evident, ja que hi ha ordinadors que tenen parts
de diferents fabricants. Per exmple, tenim /"Dell/Sun/IBM"/ o /"IBM/HP"/.
Per tal de simplificar, en aquests casos assumeixo que el primer dels fabricants
mencionats és el principal i els unifico com a tals:

#+BEGIN_SRC R :exports code :results silent
  # Unifiquem noms de fabricants
  top500$manufacturer <- mergelevels(top500$manufacturer,
                                     '^Cray', 'Cray')
  top500$manufacturer <- mergelevels(top500$manufacturer,
                                     '^Dell', 'Dell', ignore.case = TRUE)
  top500$manufacturer <- mergelevels(top500$manufacturer,
                                     '^(IBM|Lenovo)', 'IBM')
  top500$manufacturer <- mergelevels(top500$manufacturer,
                                     '^(HP|Hewlett)', 'HP')
  top500$manufacturer <- mergelevels(top500$manufacturer,
                                     'Fujitsu', 'Fujitsu')
  top500$manufacturer <- mergelevels(top500$manufacturer,
                                     'NEC', 'NEC')
  top500$manufacturer <- mergelevels(top500$manufacturer,
                                     'Hitachi', 'Hitachi')
  top500$manufacturer <- mergelevels(top500$manufacturer,
                                     'ClusterVision', 'ClusterVision')
  top500$manufacturer <- mergelevels(top500$manufacturer,
                                     'T-Platforms', 'T-Platforms')
  top500$manufacturer <- mergelevels(top500$manufacturer,
                                     'NSSOL', 'NSSOL')
  top500$manufacturer <- mergelevels(top500$manufacturer,
                                     'SGI|Networx', 'SGI')
  top500$manufacturer <- mergelevels(top500$manufacturer,
                                     'Kendall|KSR', 'KSR')
  top500$manufacturer <- mergelevels(top500$manufacturer, 'Raytheon',
                                     'Raytheon-Aspen Systems')
  top500$manufacturer <- mergelevels(top500$manufacturer,
                                     'supermicro', 'SuperMicro',
                                     ignore.case = TRUE)
  # Unifiquem diversos dissenys propis del NRCPC a la Xina
  top500$manufacturer <- mergelevels(top500$manufacturer,
                                     'NRCPC|National Research|University',
                                     'Self-made')
#+END_SRC

Després de d'aquestes correccions hem rebaixat el nombre de fabricants diferents
de src_R{fabricants} a src_R{nlevels(top500$manufacturer)}.

*** Sistemes operatius duplicats
    :PROPERTIES:
    :CUSTOM_ID: duplicate-os
    :END:

La variable /os/ (sistema operatiu) té src_R{nlevels(top500$os)} valors
diferents, però hi ha força casos on la diferència correspòn a la versió del
sistema operatiu (per exemple /"RHEL 7.2"/ i /"RHEL 7.3"/). Aquestes diferències
no aporten gaire informació als possibles anàlisis que poguem fer, o sigui que
procedirem a agrupar els sistemes operatius repetits descartant-ne lleugeres
variacions:

#+BEGIN_SRC R :exports code :results silent
  # Agrupem diferents versions d'un mateix sistema operatiu
  top500$os <- mergelevels(top500$os, 'OSF/1', 'OSF/1')
  top500$os <- mergelevels(top500$os, 'Windows', 'Windows')
  top500$os <- mergelevels(top500$os, 'UNICOS', 'UNICOS')
  top500$os <- mergelevels(top500$os, 'Ubuntu', 'Ubuntu')
  top500$os <- mergelevels(top500$os, 'bullx', 'Bullx', ignore.case = TRUE)
  top500$os <- mergelevels(top500$os, 'redhat|rhel',
                           'Red Hat Enterprise Linux',
                           ignore.case = TRUE)
  top500$os <- mergelevels(top500$os, 'suse|SLES', 'SuSE Linux',
                           ignore.case = TRUE)
#+END_SRC

#+RESULTS:

Després d'això la variable /os/ ha passat a tenir src_R{nlevels(top500$os)}
valors diferents.

*** CANCELLED COMMENT Ordinadors que han evolucionat entre edicions

No cal, ja està corregit a la captura de les dades, agafant la informació de la
llista en comptes de la pàgina de detall. El problema d'inconsistència és a la
pàgina web de TOP500.

*** CANCELLED COMMENT Co-processadors que no ho son

No disposem de prou informació especialitzada, completa i fàcilment disponible
per poder processar adequadament els coprocessadors.

** Valors perduts, zeros o buits
   :PROPERTIES:
   :CUSTOM_ID: valors-nuls
   :END:
# Les dades contenen zeros o elements buits? Com gestionaries aquests casos?

La funció ~summary~ ens ajuda a trobar quines variables conenen valors buits (i
quants) i fer-nos una idea del rang de valors cobert, i detectar per tant la
presència de zeros que poden ser indicatius d'un error a les dades:

#+BEGIN_SRC R :exports both :results output
  # El resum del data frame ens permet veure quines variables
  # contenen NAs
  summary(top500)
#+END_SRC

#+RESULTS:
#+begin_example
    manufacturer      cores              memory       
 HPE      :7918   Min.   :       1   Min.   :      8  
 IBM      :7043   1st Qu.:      96   1st Qu.:  14976  
 Cray Inc.:2989   Median :     960   Median :  48384  
 Oracle   :1224   Mean   :   16853   Mean   : 117538  
 Fujitsu  : 702   3rd Qu.:    9504   3rd Qu.: 125440  
 NEC      : 597   Max.   :19860000   Max.   :7685540  
 (Other)  :4527                      NA's   :21379    
                  processor               interconnect        rmax        
 Xeon E5-2670 8C 2.6GHz: 1120   Gigabit Ethernet: 5053   Min.   :    0.4  
 POWER3  375MHz        :  597   Infiniband      : 1399   1st Qu.:   10.3  
 POWER2  66MHz         :  553   SP Switch       : 1378   Median :   55.7  
 Xeon E5450 4C 3GHz    :  529   10G Ethernet    : 1349   Mean   :  368.5  
 R10000  195MHz        :  469   Infiniband FDR  : 1301   3rd Qu.:  277.8  
 PowerPC 604e  332MHz  :  444   (Other)         :10293   Max.   :93014.6  
 (Other)               :21288   NA's            : 4227                    
     rpeak               nmax              nhalf              hpcg       
 Min.   :     0.5   Min.   :    1900   Min.   :    112   Min.   :  1.70  
 1st Qu.:    15.2   1st Qu.:   23000   1st Qu.:   2400   1st Qu.: 31.50  
 Median :    85.4   Median :  200000   Median :   5200   Median : 80.79  
 Mean   :   574.2   Mean   :  983267   Mean   :  48915   Mean   :141.78  
 3rd Qu.:   416.4   3rd Qu.: 1486952   3rd Qu.:  18560   3rd Qu.:167.05  
 Max.   :125435.9   Max.   :16662804   Max.   :1834944   Max.   :602.74  
                    NA's   :14068      NA's   :18993     NA's   :24610   
     power                       os                         compiler    
 Min.   :   18.0   Linux          :10990   Intel                :   90  
 1st Qu.:  172.0   AIX            : 2843   icc                  :   83  
 Median :  374.0   UNICOS         : 2000   Intel 12.1           :   82  
 Mean   :  862.5   IRIX           : 1314   GCC                  :   75  
 3rd Qu.:  831.0   HP Unix (HP-UX): 1294   intel parallel studio:   44  
 Max.   :19431.0   Solaris        : 1091   (Other)              :  653  
 NA's   :17970     (Other)        : 5468   NA's                 :23973  
               math                                      mpi       
 MKL             :  228   Intel MPI                        :  248  
 Intel MKL       :  188   MVAPICH 1.2                      :   60  
 mkl             :   43   OPEN MPI                         :   40  
 MKL - 11.3.3.210:   33   MPICH2 with a custom GLEX channel:   36  
 MKL,CUDA6.5     :   23   Intel MPI 4.0                    :   34  
 (Other)         :  335   (Other)                          :  658  
 NA's            :24150   NA's                             :23924  
               gpu                  country        system_id    
 GigE            :  448   United States :12675   174016 :   16  
 Gig-Ethernet    :  334   Japan         : 2346   176819 :   16  
 Custom          :  301   Germany       : 1924   176908 :   16  
 Xeon 54xx 3.0GHz:  263   China         : 1695   176899 :   15  
 Xeon 51xx 3.0GHz:  171   United Kingdom: 1446   176924 :   15  
 (Other)         : 5274   France        : 1026   176928 :   15  
 NA's            :18209   (Other)       : 3888   (Other):24907  
         city             segment           year           rank      
 Tokyo     :  549   Academic  : 5010   Min.   :1993   Min.   :  1.0  
 Livermore :  368   Classified:  432   1st Qu.:1999   1st Qu.:125.8  
 Los Alamos:  336   Government: 1009   Median :2005   Median :250.5  
 Houston   :  331   Industry  :11601   Mean   :2005   Mean   :250.5  
 Beijing   :  317   Others    :    7   3rd Qu.:2011   3rd Qu.:375.2  
 (Other)   :12893   Research  : 6110   Max.   :2017   Max.   :500.0  
 NA's      :10206   Vendor    :  831
#+end_example

De la sortida en podem destacar uns quants aspectes:

  - Les variables /rpeak/ i /rmax/ no contenen valors buits (/NA/), però
    aparenten tenir zeros (Min == 0). Cal notar que per aquestes variables el
    zero no és un valor vàlid: qualsevol ordinador té una velocitat de càlcul
    superior a 0. Al verificar les dades, però, resulten ser els sistemes en les
    darreres posicions de les primeres llistes, amb velocitats de càlcul
    inferior a 1 GFlop/s (fraccions entre 0 i 1). És a dir: en aquestes dues
    variables, fonamentals per l'anàlisi, no hi ha valors buits o zeros.

  - Altres variables sense valors buits o zeros i que poden ser útils per
    anàlisi són: /segment/, /country/, /manufacturer/, /cores/

  - Hi ha algunes variables que contenen un nombre molt elevat de valors nuls
    (més de la meitat de les observacions, en alguns casos la pràctica
    totalitat): /math/, /hpcg/, /nmax/, /nhalf/, /power/, /compiler/, /mpi/,
    /gpu/, /memory/.

  - Altres variables contenen valors buits però en una proporció menor:
    /interconnect/, /os/.

En resum: tenim algunes variables de bona qualitat, sense valors nuls o invàlids
i que són rellevants per a l'anàlisi. D'altres contenen valors nuls, que són
vàlids en el sentit que reflexen la manca d'informació.

No faré cap més tractament d'aquests valors perduts, els mantindrem tal i com
estan. Les alternatives per tractar-los no tenen sentit en aquest cas: no volem
descartar registres sencers només perquè els manca informació de, per exemple,
quin compilador fan servir; tampoc tenim a l'abast omplir la informació que
falta; no té gaire sentit tampoc en el nostre cas intentar calcular valors per
les variables afectades, sobretot a les variables on la majoria dels valors són
buits (i a les que no, com /os/, un valor calculat no ens aportaria més valor
per a l'anàlisi que un valor buit). Simplement acceptarem aquesta presència de
valors buits i ho tindrem en compte a l'hora de l'anàlisi. Amb un parell
d'excepcions, però, que veurem a continuació.

*** Descartar variables

Comentava que no tractarem valors perduts a nivell de registres (files), però si
que hi ha dues variables (columnes) que descartarem senceres.

La variable /gpu/ a més de tenir un elevat nombre de valors nuls també conté
valors invàlids: com comentàvem a l'apartat d'[[#integ][integració i selecció de les
dades]], sabem que el contingut de /gpu/ és imprecís i no s'ha pogut
corregir. Aquesta variable, doncs, no ens servirà i la descartarem:

#+BEGIN_SRC R :results silent :exports code
  # Descartem la vairable gpu pel seu elevat nombre de valors
  # nuls i invàlids
  top500 <- subset(top500, select = -gpu)
#+END_SRC

L'altre cas és la variable /hpcg/: és la variable que té més valors nuls, un
src_R{sum(is.na(top500$hpcg)) / nrow(top500) * 100} % dels seus valors són buits.
A més, els pocs valors que té només es troben a les edicions més recents de la
llista TOP500:

#+BEGIN_SRC R :exports both :results output
  # Comprovem que només tenim valors d'hpcg per les edicions recents
  table(top500[! is.na(top500$hpcg), "edition" ])
#+END_SRC

#+RESULTS:
: 
: 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 
:  1  1  4  5 10 13 15 17 21 23 32 35 43 52 58 60

Tot plegat, això vol dir que no ens servirà gaire per dur a terme el tipus
d'estudi que volem fer aquí, basat en l'evolució al llarg dels anys. Per tant,
també la descartem:

#+BEGIN_SRC R :results silent :exports code
  # Descartem la vairable hpcg pel seu elevat nombre de valors
  # buits i la seva nul·la presència a les primeres 34 edicions
  top500 <- subset(top500, select = -hpcg)
#+END_SRC

*** Valors "N/A"

Durant la feina de neteja amb [[#duplicate-os][sistemes operatius duplicats]] hem vist que hi ha
alguns registres de la variable /os/ que tenen el valor "N/A". No el valor nul
/NA/ sinó una cadena de caràcters (de fet, un factor en aquest cas) amb el
valor textual "N/A". Per reflectir adequadament el seu significat (informació no
disponible), substituirem aquests valors per el valor nul, que R representa com
/NA/.

Repassant les altres variables també he trobat el mateix tipus de problema a la
variable /compiler/, o sigui que hi aplicarem el mateix tipus de correcció:

#+BEGIN_SRC R :results silent :exports code
  # Corregir el valor del factor "N/A" reemplaçant-lo per NA
  # a les variable os i compiler
  top500[!is.na(top500$os) & top500$os == "N/A", "os"] <- NA
  top500[!is.na(top500$compiler) & top500$compiler == "N/A", "compiler"] <- NA
  # Desfer-nos de la categoria "N/A" ara que està buida
  top500$os <- factor(top500$os)
  top500$compiler <- factor(top500$compiler)
#+END_SRC

** Valors extrems
   :PROPERTIES:
   :CUSTOM_ID: xtreme
   :END:
# Identificació i tractament de valors extrems.

Estem treballant amb dades de superordinadors, és a dir, ordinadors "extrems", i
no serà sorprenent que ens trobem també amb valors extrems a les dades. Vegem-ho.

Tenint en compte que les dades contenen informació sobre la potència de càlcul
dels superordinadors (a les variables /rmax/ i /rpeak/) al llarg de 25 anys, i
amb la llei de Moore al cap, ja podem suposar que ens toparem amb una
distribució força esbiaixada dels valors numèrics: els ordinadors actuals són
molt més potents que els de fa 25 anys.

\cite{dalgaard_02} posa un exemple d'aquesta situació basat en \cite{altman_91}
i suggereix transformar aquest tipus de dades utilitzant logaritmes per
aconseguir una distribució més simètrica.

Aplicant-ho a les variables /rmax/ i /cores/, en veiem el resultat a la figura
[[fig:boxplot-rmax]].

#+BEGIN_SRC R :results graphics :exports both :file boxplot-log-rmax.png
  # Boxplot de rmax i cores i els seu logaritme, un al costat de l'altre
  par(mfrow=c(2,2))
  boxplot(top500$rmax, xlab = "rmax")
  boxplot(log(top500$rmax), xlab = "log(rmax)")
  boxplot(top500$cores, xlab = "cores")
  boxplot(log(top500$cores), xlab = "log(cores)")
#+END_SRC

#+NAME: fig:boxplot-rmax
#+CAPTION: Boxplot de /rmax/ i /cores/ i els seus logaritmes
#+RESULTS:
[[file:boxplot-log-rmax.png]]

Es pot veure com el boxplot dels valors reals ens permet veure només valors
extrems, mentre que el dels logaritmes dels valors ens presenta una distribució
molt més /normal/. Això ens està mostrant la distribució exponencial del
rendiment i del nombre de nuclis de còmput, coherent amb el que esperàvem.

Passa el mateix amb totes les variables numèriques que tenim: resulta que totes
les variables numèriques presenten valors que normalment es considerarien
extrems. Com deiem, però, en el nostre cas és una situació esperada. No es
tracta d'errors de captura, registre o mostreig; simplement, les dades amb què
treballem són així: és precisament com han evolucionat els ordinadors, i és
el que volem analitzar.

Per tant no hem de modificar, eliminar o amagar aquests valors, simplement
hem de ser conscients de com són les dades amb les que estem treballant en
aquest cas.

** COMMENT Reducció
*** De dimensions (variables)

Ja s'han eliminat les variables que calia durant la integració i la neteja.

*** De valors

No aplica; volem tots els 25.000 registres, i no ens genera problemes de
capacitat de tractament.

** Atributs calculats

De cara a possibles anàlisi ens pot interessar preparar algun atribut addicional
calculat a partir de les dades existents.

Abans ja [[#edition][hem creat el número d'edició]] i la data de cada llista amb finalitats
pràctiques, per facilitar-nos referenciar les dades. Més enllà d'això també
podem generar nous atributs que ens serveixin directament per a l'anàlisi.

*** Familia de Sistema Operatiu
    :PROPERTIES:
    :CUSTOM_ID: osfamily
    :END:

Anteriorment hem [[*Sistemes operatius duplicats][simplificat la informació de sistemes operatius]] eliminant
detalls de versió que no són rellevants per als anàlisi. Tot i això, encara
ens queden src_R{nlevels(top500$os)} sistemes operatius diferents, i de cara
a analitzar l'evolució dels sistemes operatius dels superordinadors ens pot
anar bé tenir-los agrupats per famílies o tipus de sistema operatiu.

Crearem un nou atribut /osfamily/ agrupant els sistemes operatius en 3 grans
families: "Unix", "Linux" i "Windows".

#+BEGIN_SRC R :exports both
  # Agrupació de sistemes operatius per families
  top500$osfamily <- top500$os

  linux <- c(
      'Linux', 'Ubuntu', 'CentOS', 'Bullx', 'RaiseOS', 'TOSS', 'CNL'
  )
  top500$osfamily <- mergelevels(top500$osfamily,
                                 paste0(linux, collapse="|"),
                                 'Linux', ignore.case = TRUE)

  unix <- c(
      'AIX', 'IRIX', 'HP', 'Unix', 'CMOST', 'Solaris', 'SunOS',
      'MacOS', 'HI-UX', 'Ultrix', 'PARIX', 'Super-UX', 'UNICOS',
      'ConvexOS', 'SPP-UX', 'Tru64', 'OSF/1', 'KSR', 'EWS', 'UXP'
  )
  top500$osfamily <- mergelevels(top500$osfamily,
                                 paste0(unix, collapse = "|"),
                                 'Unix', ignore.case = TRUE)

  other <- c('Cell OS', 'CRS-OS', 'NX/2', 'Paragon')
  top500$osfamily <- mergelevels(top500$osfamily,
                                 paste0(other, collapse="|"),
                                 'Other')
  table(top500$osfamily)
#+END_SRC

#+RESULTS:
| Unix    | 11457 |
| Linux   | 13280 |
| Other   |   126 |
| Windows |    50 |

** COMMENT Discretització?
** COMMENT Normalització?
** Desar les dades netejades

Un cop tenim les dades a punt per fer anàlisi, en desem una còpia com a
referència per poder carregar-les ja processades quan convingui:

#+BEGIN_SRC R :results silent :exports code
  # Desem les dades pre-processades
  write.csv(top500, '../data/top500-clean.csv', row.names = FALSE)
#+END_SRC

* Anàlisi de les dades

A la [[#descr][descripció del dataset]] platejàvem unes quantes preguntes que ens podríem
plantejar a partir de les dades de què disposem:

  1. Es poden veure els efectes de la predicció/llei de Moore?
  2. Com han evolucionat els fabricants o els sistemes operatius utilitzats pels
     superordinadors?
  3. Quins països disposen de superordinadors?
  4. Podem establir quins factors contribueixen més a l'augment de la potència
     de càlcul? (memòria, CPU, potència consumida)

Per respondre a les tres primeres preguntes el millor és representar
adequadament la informació de què disposem, no cal dur a terme càlculs
específics, i per tant ho afrontarem a la secció de [[#repr][representació dels
resultats]].

En canvi, per estudiar com afecten els processadors, memòria o potència a la
velocitat de càlcul si que ens caldrà obtenir models estadístics, que és
el que farem en aquest apartat.

** Selecció dels grups de dades a analitzar/comparar
# (planificació dels anàlisis a aplicar)

Ens disposem a analitzar quins factors contribueixen més a l'augment de
velocitat de càlcul dels superordinadors (representada per la variable /rmax/).

Començarem per buscar possibles factors entre les altres variables numèriques de
què disposem. Les variables /rpeak/, /nmax/ i /nhalf/ estan relacionades
directament amb /rmax/: totes són mesures relacionades amb la velocitat de
càlcul. Podría ser interessant especialistes, sobretot pels fabricants de
superordinadors, estudiar relacions entre elles, però a nosaltres el que ens
interessa és comparar el rendiment real assolit (/rmax/) amb altres factors.

Mirarem, doncs, les altres variables numèriques que ens queden: /cores/,
/memory/ i /power/.

Com a primer pas farem una visualització per parelles per veure si s'aprecia
alguna aparent correlació (figura [[fig:pairs-rmax]]). Tal i com hem comentat quan
hem revisat els [[#xtreme][valors extrems]], treballem amb els logaritmes dels valors per
tal de visualitzar de forma lineal el seu comportament exponencial.

#+BEGIN_SRC R  :results graphics :file pairs-rmax.png :exports both
  # Diagrames de punts per parelles de les variables numèriques
  # candidates a comparar
  pairs(~ rmax + cores + memory + power, data = top500, log = "xy")
#+END_SRC

#+NAME: fig:pairs-rmax
#+CAPTION: Diagrames de punts per parelles de les variables numèriques candidates a comparar amb el rendiment
#+RESULTS:
[[file:pairs-rmax.png]]

Aparentment s'observen relacions entre el rendiment i la resta de variables, especialment
amb el nombre de nuclis.

Ho confirmarem amb les [[#tests][proves estadístiques]].

*** CANCELLED COMMENT millorar presentacio amb ggpairs

# escala logaritmica amb ggpairs: https://github.com/ggobi/ggally/issues/250

** Comprovació de la normalitat i homogeneïtat de la variància
   :PROPERTIES:
   :CUSTOM_ID: distribution
   :END:

Tal i com hem comentat durant la [[#xtreme][revisió de valors extrems]], les dades amb què
treballem no segueixen una distribució normal, com es veu clarament si representem
els valors de rmax al llarg de les diferents edicons.

Per fer-ho utilitzarem només el darrer ordinador de cada llista (el que ocupa la
posició número 500); això és perquè aquest representa l'evolució de la potència
de càlcul d'una manera més suau i realista: accedir a la posició número 1 és
molt difícil i ens trobem que només hi ha canvis a la posició 1 de la llista quan
al món algú desenvolupa l'ordinador més potent del moment, cosa que no succeeix
amb facilitat; en canvi, quan més avall a la llista, més disputada està la plaça
i per tant l'evolució de la última plaça és la que representa millor l'evolució
global de la velocitat de càlcul[fn:3].

#+BEGIN_SRC R :results graphics :exports both :file bottom500.png
  # Visualitzem la potència de càlcul de l'últim ordinador de cada
  # edició de la llista TOP500
  bottom500 <- top500[top500$rank == 500, ]
  with(bottom500, plot(edition, rmax))
#+END_SRC

#+RESULTS:
[[file:bottom500.png]]

** Aplicació de proves estadístiques
   :PROPERTIES:
   :CUSTOM_ID: tests
   :END:
# ... per comparar els grups de dades.
#
# En funció de les dades i de l’objectiu de l’estudi, aplicar proves de contrast
# d’hipòtesis, correlacions, regressions, etc.

Anem a veure quina de les tres variables /memory/, /cores/ i /power/ té més
relació amb el rendiment dels ordinadors (/rmax/).

Per fer-ho aplicarem un model de regressió entre /rmax/ i cadascuna d'elles,
compararem quin encaixa millor i quins són els respectius índex de correlació.

#+BEGIN_SRC R :exports both :results output
  # Regressió entre rmax i cores
  rmaxcores <- lm(log10(top500$rmax) ~ log10(top500$cores))
  summary(rmaxcores)
#+END_SRC

#+RESULTS:
#+begin_example

Call:
lm(formula = log10(rmax) ~ log10(cores))

Residuals:
    Min      1Q  Median      3Q     Max 
-4.2254 -0.2339  0.0703  0.3124  2.2617 

Coefficients:
              Estimate Std. Error t value Pr(>|t|)    
(Intercept)  -0.873142   0.009574   -91.2   <2e-16 ***
log10(cores)  1.419542   0.003015   470.9   <2e-16 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

Residual standard error: 0.5879 on 24998 degrees of freedom
Multiple R-squared:  0.8987,	Adjusted R-squared:  0.8987 
F-statistic: 2.217e+05 on 1 and 24998 DF,  p-value: < 2.2e-16
#+end_example

#+BEGIN_SRC R :exports both :results output
  # Regressió entre rmax i memory
  rmaxmem <- lm(log10(top500$rmax) ~ log10(top500$memory))
  summary(rmaxmem)
#+END_SRC

#+RESULTS:
#+begin_example

Call:
lm(formula = log10(top500$rmax) ~ log10(top500$memory))

Residuals:
    Min      1Q  Median      3Q     Max 
-3.4195 -0.2610 -0.0287  0.2525  2.3887 

Coefficients:
                     Estimate Std. Error t value Pr(>|t|)    
(Intercept)           1.16229    0.04825   24.09   <2e-16 ***
log10(top500$memory)  0.91416    0.01036   88.20   <2e-16 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

Residual standard error: 0.4453 on 3619 degrees of freedom
  (21379 observations deleted due to missingness)
Multiple R-squared:  0.6825,	Adjusted R-squared:  0.6824 
F-statistic:  7780 on 1 and 3619 DF,  p-value: < 2.2e-16
#+end_example

#+BEGIN_SRC R :exports both :results output
  # Regressió entre rmax i power
  rmaxpower <- lm(log10(top500$rmax) ~ log10(top500$power))
  summary(rmaxpower)
#+END_SRC

#+RESULTS:
#+begin_example

Call:
lm(formula = log10(top500$rmax) ~ log10(top500$power))

Residuals:
     Min       1Q   Median       3Q      Max 
-2.86498 -0.35771 -0.06859  0.43162  1.82276 

Coefficients:
                    Estimate Std. Error t value Pr(>|t|)    
(Intercept)          2.19657    0.03621   60.66   <2e-16 ***
log10(top500$power)  1.12273    0.01362   82.43   <2e-16 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

Residual standard error: 0.5766 on 7028 degrees of freedom
  (17970 observations deleted due to missingness)
Multiple R-squared:  0.4915,	Adjusted R-squared:  0.4915 
F-statistic:  6794 on 1 and 7028 DF,  p-value: < 2.2e-16
#+end_example

Comparant els índex de correlació $R^2$ veiem que la variable /cores/ (número de
nuclis) és la que presenta una correlació més elevada, de 0.899, mentre que en
el cas de /power/ (consum) baixa fins a 0.49.

A l'apartat següent representarem gràficament aquestes [[#relations][relacions entre potència]] i les altres
variables i ho confirmarem de manera més visual.

Comentar també que aquí tornem a veure la presència de valors buits a les
dades: a part de /rmax/, només /cores/ conté valors a tots els registres, mentre
que per a /power/ i sobretot /memory/ s'han descartat automàticament un gran
nombre d'entrades per tenir valor buit.

* Representació dels resultats
  :PROPERTIES:
  :CUSTOM_ID: repr
  :END:
# ... a partir de taules i gràfiques

Representant gràficament les dades n'obtenim informació important. De fet, és la
millor manera de resoldre un dels objectius que hem plantejat al principi: el
d'observar les conseqüències de la llei de Moore.

** Verificació de la llei de Moore
   :PROPERTIES:
   :CUSTOM_ID: moore
   :END:

Anem a visualitzar l'evolució de la capacitat de càlcul dels superordinadors
durant els darrers 25 anys, representada pel seu rendiment Linpak mesurat en
milers de milions d'operacions de càlcul per segon (GFlop/s), que a les dades
que tenim correspòn a la variable /rmax/.

Quan hem comentat [[#distribution][al parlar de la distribució de les dades]] hem explicat que
fixar-nos en l'ordinador a la posició 500 ens permet observar millor l'evolució
en global. D'altra banda, també pot resultar interessant veure l'evolució del
superordinador més potent (a la posició 1 de la llist). Representarem, doncs,
l'evolució de tots dos ordinadors (primer i últim) per a cada edició.

A \cite{r4ds} es suggereix utilitzar el paquet /ggplot2/ de R, i l'utilitzo en
alguns dels gràfics a continuació.

#+BEGIN_SRC R :results graphics :file performance-over-time.png :exports both
  library(ggplot2)
  # Dibuixem l'evolució del rendiment del primer i últim ordinador de
  # cada llista al llarg del temps. Segons la llei de Moore aquesta
  # progressió és exponencial, i per tant fem servir una escala logarítmica
  # a l'eix del rendiment. Hi dibuixem també models lineals per
  # visualitzar millor l'evolució
  ggplot(data = top500[top500$rank == 1 | top500$rank == 500, ],
         aes(x = edition, y = rmax, colour = factor(rank))) +
      labs(x = 'Edició de la llista', y = 'Rendiment (rmax GFlop/s)',
           colour = 'Posició') +
      geom_point() +
      geom_smooth(data = top500[top500$rank == 1,], method = 'lm') +
      geom_smooth(data = top500[top500$rank == 500,], method = 'lm') +
      scale_y_log10()
#+END_SRC

#+NAME: fig:perf-time
#+CAPTION: Evolució del rendiment amb el temps
#+RESULTS:
[[file:performance-over-time.png]]

Efectivament, a la figura [[fig:perf-time]] veiem la progressió exponencial
(recordem que la representació és en escala logarítmica) que han seguit
fidelment els superordinadors, conseqüència directa de la predicció de
Moore.

Com a curiositat, també veiem a la gràfica que al voltant de la 17a edició de la
llista (o sigui, en un interval d'entre 8 i 9 anys) l'ordinador menys potent de
la llista ja era més potent que el primer de la primera edició.

** Relacions entre potència, memòria, nuclis i consum
   :PROPERTIES:
   :CUSTOM_ID: relations
   :END:

Aquí visualitzarem gràficament les [[#tests][proves estadístiques]] que hem fet per comparar
el número de nuclis de computació (/cores/), la quantitat de memòria (/memory/)
i el consum energètic (/power/) dels superordinadors amb el seu rendiment
(/rmax/).

*** Potència vs nuclis

Començarem per la variable que hem vist que està més relacionada amb el
rendiment: el número de nuclis.

 #+BEGIN_SRC R :results graphics :exports both :file rmax-cores.png
   # rmax vs cores
   ggplot(data = top500, aes(x = rmax, y = cores)) +
       geom_point() + geom_smooth() +
       scale_x_log10() + scale_y_log10()
 #+END_SRC

 #+RESULTS:
 [[file:rmax-cores.png]]

Podem veure la relació pràcticament lineal (en escala logarítmica) amb claredat.

*** Potència vs memòria

Representem ara la relació amb la memòria. Recordem que en aquest cas disposem
de moltes menys dades, i per tant el gràfic conté molts menys punts:

 #+BEGIN_SRC R :results graphics :exports both :file rmax-mem.png
   # rmax vs memory
   ggplot(data = top500[top500$rmax > 1000,], aes(x = rmax, y = memory)) +
       geom_point() + geom_smooth(se = FALSE) +
       scale_x_log10() + scale_y_log10()
 #+END_SRC

 #+RESULTS:
 [[file:rmax-mem.png]]

Comparant-lo amb el gràfic del número de nuclis veiem que, efectivament, el
núvol de punts és més dispers al voltant de la possible recta de regressió,
indicant-nos que no és un factor tant determinant.

*** Consum per potència

 #+BEGIN_SRC R :results graphics :exports both :file rmax-power.png
   # rmax vs power
   ggplot(data = top500[top500$rmax > 1000,], 
          aes(x = rmax, y = power)) +
       geom_point() + geom_smooth(se = FALSE) +
       scale_x_log10() + scale_y_log10()
 #+END_SRC

 #+RESULTS:
 [[file:rmax-power.png]]

En el cas del consum energètic encara ens trobem amb més dispersió. De fet, ens
caldria forçar que la visualització utilitzi un model lineal de regressió, ja
que altrament el mètode d'aproximació automàtic no ens aproxima tan bé una recta
com els anteriors.

*** Consum per nuclis

Com a visualització addicional no relacionada amb la cerca dels factors que
contribueixen al rendiment, representarem també el consum en funció del nombre
de nuclis. La idea és intentar veure si el consum energètic augmenta de forma
proporcional al factor que hem vist que contribueix més al rendiment.

 #+BEGIN_SRC R :results graphics :exports both :file cores-power.png
   # power vs cores
   ggplot(data = top500[top500$cores > 100,], aes(x = cores, y = power)) +
       geom_point() + geom_smooth(method = "lm") +
       scale_x_log10() + scale_y_log10()
 #+END_SRC

 #+RESULTS:
 [[file:cores-power.png]]

** CANCELLED COMMENT Segments
   CLOSED: [2018-06-11 Mon 22:46]
   :LOGBOOK:
   - State "CANCELLED"  from "TODO"       [2018-06-11 Mon 22:46] \\
     Ran out of time
   :END:

*** TODO eliminar sistemes duplicats!

#+BEGIN_SRC R :results graphics :exports both :file segments.png
   ggplot(data = top500, aes(x = segment)) +
       geom_bar()
#+END_SRC

#+RESULTS:
[[file:segments.png]]

*** Per potència 
#+BEGIN_SRC R :results graphics :exports both :file segments-rmax.png
   ggplot(data = top500, aes(x = segment, y = rmax)) +
       geom_bar(stat = "identity")
#+END_SRC

#+RESULTS:
[[file:segments-rmax.png]]

*** TODO Unificar les dues gràfiques
** CANCELLED COMMENT Evoloució families SO
   CLOSED: [2018-06-11 Mon 22:47]
   :LOGBOOK:
   - State "CANCELLED"  from "TODO"       [2018-06-11 Mon 22:47] \\
     ran out of time
   :END:

** CANCELLED COMMENT Evolució de fabricants
   CLOSED: [2018-06-11 Mon 22:47]
   :LOGBOOK:
   - State "CANCELLED"  from "TODO"       [2018-06-11 Mon 22:47] \\
     ran out of time
   :END:

** CANCELLED COMMENT Evolució dels països
   CLOSED: [2018-06-11 Mon 22:47]
   :LOGBOOK:
   - State "CANCELLED"  from "TODO"       [2018-06-11 Mon 22:47] \\
     ran out of time
   :END:

* Resolució del problema
# A partir dels resultats obtinguts, quines són les conclusions? Els resultats permeten respondre al problema?

Resumim les conclusions del que hem observat a les dades.

D'entrada hem pogut [[#moore][observar l'efecte de la llei de Moore]], veient que la
potència/velocitat de càlcul dels superordinadors ha progressat de forma
exponencial durant els darrers 25 anys, seguint la predicció.

També hem vist que el factor que més contribueix a la potència de càlcul
és [[#tests][el nombre de nuclis]] de computació.

Potser aquestes observacions no ens resultin gaire sorprenents, però
l'exercici ens ha permès verificar que la història dels superordinadors
segueix els paràmetres que se n'esperava.

* Codi
# Cal adjuntar el codi, preferiblement en R, amb el que s’ha realitzat la
# neteja, anàlisi i representació de les dades. Si ho preferiu, també podeu
# treballar en Python.

Aquest anàlisi ha estat desenvolupat amb Emacs org-mode i ESS \cite{doc:ess}, i
el codi R que es troba contingut en l'arxiu font de l'anàlisi s'ha extret
automàticament i es pot consultar de forma independent a l'arxiu [[file:analisi.R][analisi.R]].


\bibliographystyle{plain}
\bibliography{analisi}

* Footnotes

[fn:3] recordem que no ens interessa tant el valor absolut de rendiment com l'estudi de la seva evolució all llarg del temps

[fn:2] Edició de Novembre de 2004 mostrant unitats en GFlops: https://www.top500.org/lists/2004/11/

[fn:1] Edició de Novembre de 2004 mostrant unitats en TFlops: https://www.top500.org/lists/2005/06/


